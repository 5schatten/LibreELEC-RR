From 84616ccb41166c04ad4c0788a5737ddc2d69307b Mon Sep 17 00:00:00 2001
From: Dave Stevenson <dave.stevenson@raspberrypi.org>
Date: Thu, 15 Feb 2018 16:18:06 +0000
Subject: [PATCH 25/80] staging: bcm2835-camera: Use zero copy if VC-SM is
 configured

If we have CONFIG_BCM_VC_SM then we can import dmabufs from
videobuf2-dma-contig to the VPU and use those, instead of
making VCHIQ do a memcpy of all data from the VPU.

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.org>
---
 .../vc04_services/bcm2835-camera/Kconfig      |  1 +
 .../vc04_services/bcm2835-camera/Makefile     |  1 +
 .../bcm2835-camera/bcm2835-camera.c           | 86 ++++++++++++++++++-
 .../bcm2835-camera/mmal-common.h              |  5 ++
 .../vc04_services/bcm2835-camera/mmal-vchiq.c | 71 ++++++++++++++-
 .../vc04_services/bcm2835-camera/mmal-vchiq.h |  2 +
 6 files changed, 161 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/vc04_services/bcm2835-camera/Kconfig b/drivers/staging/vc04_services/bcm2835-camera/Kconfig
index 1fda52a09d40..b482dbc60c8e 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/Kconfig
+++ b/drivers/staging/vc04_services/bcm2835-camera/Kconfig
@@ -2,6 +2,7 @@ config VIDEO_BCM2835
 	tristate "BCM2835 Camera"
 	depends on MEDIA_SUPPORT
 	depends on VIDEO_V4L2 && (ARCH_BCM2835 || COMPILE_TEST)
+	select BCM_VC_SM
 	select BCM2835_VCHIQ
 	select VIDEOBUF2_DMA_CONTIG
 	select BTREE
diff --git a/drivers/staging/vc04_services/bcm2835-camera/Makefile b/drivers/staging/vc04_services/bcm2835-camera/Makefile
index 2a4565e682d8..f62631b8f67b 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/Makefile
+++ b/drivers/staging/vc04_services/bcm2835-camera/Makefile
@@ -8,4 +8,5 @@ obj-$(CONFIG_VIDEO_BCM2835) += bcm2835-v4l2.o
 
 ccflags-y += \
 	-Idrivers/staging/vc04_services \
+	-Idrivers/char/broadcom/vc_sm \
 	-D__VCCOREVER__=0x04000000
diff --git a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c b/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
index f7e7b4bc3e9e..56e5d436ff25 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
+++ b/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
@@ -301,7 +301,10 @@ static int buffer_init(struct vb2_buffer *vb)
 static int buffer_prepare(struct vb2_buffer *vb)
 {
 	struct bm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
+	struct mmal_buffer *buf = container_of(vb2, struct mmal_buffer, vb);
 	unsigned long size;
+	int ret;
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
 		 __func__, dev, vb);
@@ -317,7 +320,36 @@ static int buffer_prepare(struct vb2_buffer *vb)
 		return -EINVAL;
 	}
 
-	return 0;
+#if defined(CONFIG_BCM_VC_SM)
+	/*
+	 * Two niggles:
+	 * 1 - We want to do this at init, but vb2_core_expbuf checks that the
+	 * index < q->num_buffers, and q->num_buffers only gets updated once
+	 * all the buffers are allocated.
+	 *
+	 * 2 - videobuf2 only exposes dmabufs as an fd via vb2_core_expbuf.
+	 * Ideally we'd like the struct dma_buf directly, but can't get hold of
+	 * it, so have to accept the fd and work with it.
+	 */
+	if (!buf->dma_buf) {
+		int fd;
+
+		ret = vb2_core_expbuf(vb->vb2_queue, &fd,
+				      vb->vb2_queue->type, vb->index, 0,
+				      O_CLOEXEC);
+		if (ret)
+			v4l2_err(&dev->v4l2_dev, "%s: Failed to expbuf idx %d, ret %d\n",
+				 __func__, vb->index, ret);
+		buf->dma_buf = dma_buf_get(fd);
+		/* Drop the fd's reference to the buffer */
+		dma_buf_put(buf->dma_buf);
+		/* Release the fd as we now have a ref to the dma_buf */
+		put_unused_fd(fd);
+	}
+#else
+	ret = 0;
+#endif
+	return ret;
 }
 
 static void buffer_cleanup(struct vb2_buffer *vb)
@@ -328,7 +360,13 @@ static void buffer_cleanup(struct vb2_buffer *vb)
 
 	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
 		 __func__, dev, vb);
+
 	mmal_vchi_buffer_cleanup(buf);
+
+#if defined(CONFIG_BCM_VC_SM)
+	if (buf->dma_buf)
+		dma_buf_put(buf->dma_buf);
+#endif
 }
 
 static inline bool is_capturing(struct bm2835_mmal_dev *dev)
@@ -1602,6 +1640,10 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 	u32 supported_encodings[MAX_SUPPORTED_ENCODINGS];
 	int param_size;
 	struct vchiq_mmal_component  *camera;
+#if defined(CONFIG_BCM_VC_SM)
+	unsigned int enable = 1;
+#endif
+
 
 	ret = vchiq_mmal_init(&dev->instance);
 	if (ret < 0)
@@ -1668,6 +1710,14 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 	format->es->video.frame_rate.num = 0; /* Rely on fps_range */
 	format->es->video.frame_rate.den = 1;
 
+#if defined(CONFIG_BCM_VC_SM)
+	vchiq_mmal_port_parameter_set(
+			dev->instance,
+			&camera->output[MMAL_CAMERA_PORT_PREVIEW],
+			MMAL_PARAMETER_ZERO_COPY,
+			&enable, sizeof(enable));
+#endif
+
 	format = &camera->output[MMAL_CAMERA_PORT_VIDEO].format;
 
 	format->encoding = MMAL_ENCODING_OPAQUE;
@@ -1682,6 +1732,14 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 	format->es->video.frame_rate.num = 0; /* Rely on fps_range */
 	format->es->video.frame_rate.den = 1;
 
+#if defined(CONFIG_BCM_VC_SM)
+	vchiq_mmal_port_parameter_set(
+			dev->instance,
+			&camera->output[MMAL_CAMERA_PORT_VIDEO],
+			MMAL_PARAMETER_ZERO_COPY,
+			&enable, sizeof(enable));
+#endif
+
 	format = &camera->output[MMAL_CAMERA_PORT_CAPTURE].format;
 
 	format->encoding = MMAL_ENCODING_OPAQUE;
@@ -1695,6 +1753,14 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 	format->es->video.frame_rate.num = 0; /* Rely on fps_range */
 	format->es->video.frame_rate.den = 1;
 
+#if defined(CONFIG_BCM_VC_SM)
+	vchiq_mmal_port_parameter_set(
+			dev->instance,
+			&camera->output[MMAL_CAMERA_PORT_CAPTURE],
+			MMAL_PARAMETER_ZERO_COPY,
+			&enable, sizeof(enable));
+#endif
+
 	dev->capture.width = format->es->video.width;
 	dev->capture.height = format->es->video.height;
 	dev->capture.fmt = &formats[0];
@@ -1732,6 +1798,14 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 		goto unreg_image_encoder;
 	}
 
+#if defined(CONFIG_BCM_VC_SM)
+	vchiq_mmal_port_parameter_set(
+			dev->instance,
+			&dev->component[MMAL_COMPONENT_IMAGE_ENCODE]->output[0],
+			MMAL_PARAMETER_ZERO_COPY,
+			&enable, sizeof(enable));
+#endif
+
 	/* get the video encoder component ready */
 	ret = vchiq_mmal_component_init(dev->instance, "ril.video_encode",
 					&dev->
@@ -1755,9 +1829,15 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 						 encoder_port);
 	}
 
-	{
-		unsigned int enable = 1;
+#if defined(CONFIG_BCM_VC_SM)
+	vchiq_mmal_port_parameter_set(
+			dev->instance,
+			&dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->output[0],
+			MMAL_PARAMETER_ZERO_COPY,
+			&enable, sizeof(enable));
+#endif
 
+	{
 		vchiq_mmal_port_parameter_set(
 			dev->instance,
 			&dev->component[MMAL_COMPONENT_VIDEO_ENCODE]->control,
diff --git a/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h b/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h
index aba05cdafc8b..5153f40114c6 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h
+++ b/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h
@@ -50,6 +50,11 @@ struct mmal_buffer {
 	unsigned long buffer_size; /* size of allocated buffer */
 
 	void *msg_context;
+#if defined(CONFIG_BCM_VC_SM)
+	struct dma_buf *dma_buf;/* Exported dmabuf fd from videobuf2 */
+	int vcsm_handle;	/* VCSM handle having imported the dmabuf */
+	u32 vc_handle;		/* VC handle to that dmabuf */
+#endif
 };
 
 /* */
diff --git a/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c b/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c
index 1bc6dd79f9e3..b0ab42055bf9 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c
+++ b/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.c
@@ -28,9 +28,14 @@
 #include <asm/cacheflush.h>
 
 #include "mmal-common.h"
+#include "mmal-parameters.h"
 #include "mmal-vchiq.h"
 #include "mmal-msg.h"
 
+#if defined(CONFIG_BCM_VC_SM)
+#include "vc_sm_knl.h"
+#endif
+
 #define USE_VCHIQ_ARM
 #include "interface/vchi/vchi.h"
 
@@ -491,8 +496,17 @@ buffer_from_host(struct vchiq_mmal_instance *instance,
 
 	/* buffer header */
 	m.u.buffer_from_host.buffer_header.cmd = 0;
-	m.u.buffer_from_host.buffer_header.data =
-		(u32)(unsigned long)buf->buffer;
+	if (port->zero_copy) {
+#if defined(CONFIG_BCM_VC_SM)
+		m.u.buffer_from_host.buffer_header.data = buf->vc_handle;
+#else
+		pr_warn("%s: port set to zero_copy but no VCSM", __func__);
+		m.u.buffer_from_host.buffer_header.data = 0;
+#endif
+	} else {
+		m.u.buffer_from_host.buffer_header.data =
+			(u32)(unsigned long)buf->buffer;
+	}
 	m.u.buffer_from_host.buffer_header.alloc_size = buf->buffer_size;
 	m.u.buffer_from_host.buffer_header.length = 0;	/* nothing used yet */
 	m.u.buffer_from_host.buffer_header.offset = 0;	/* no offset */
@@ -549,6 +563,20 @@ static void buffer_to_host_cb(struct vchiq_mmal_instance *instance,
 
 		msg_context->u.bulk.status = msg->h.status;
 
+	} else if (msg->u.buffer_from_host.is_zero_copy) {
+		/*
+		 * Zero copy buffer, so nothing to do.
+		 * Copy buffer info and make callback.
+		 */
+		msg_context->u.bulk.buffer_used =
+				msg->u.buffer_from_host.buffer_header.length;
+		msg_context->u.bulk.mmal_flags =
+				msg->u.buffer_from_host.buffer_header.flags;
+		msg_context->u.bulk.dts =
+				msg->u.buffer_from_host.buffer_header.dts;
+		msg_context->u.bulk.pts =
+				msg->u.buffer_from_host.buffer_header.pts;
+
 	} else if (msg->u.buffer_from_host.buffer_header.length == 0) {
 		/* empty buffer */
 		if (msg->u.buffer_from_host.buffer_header.flags &
@@ -1500,6 +1528,9 @@ int vchiq_mmal_port_parameter_set(struct vchiq_mmal_instance *instance,
 
 	mutex_unlock(&instance->vchiq_mutex);
 
+	if (parameter == MMAL_PARAMETER_ZERO_COPY && !ret)
+		port->zero_copy = !!(*(bool *)value);
+
 	return ret;
 }
 
@@ -1663,6 +1694,32 @@ int vchiq_mmal_submit_buffer(struct vchiq_mmal_instance *instance,
 	unsigned long flags = 0;
 	int ret;
 
+#if defined(CONFIG_BCM_VC_SM)
+	/*
+	 * We really want to do this in mmal_vchi_buffer_init but can't as
+	 * videobuf2 won't let us have the dmabuf there.
+	 */
+	if (port->zero_copy && buffer->dma_buf && !buffer->vcsm_handle) {
+		int ret;
+
+		ret = vc_sm_import_dmabuf(buffer->dma_buf,
+					  &buffer->vcsm_handle);
+		if (ret) {
+			pr_err("%s: vc_sm_import_dmabuf_fd failed, ret %d\n",
+			       __func__, ret);
+			return ret;
+		}
+
+		buffer->vc_handle = vc_sm_int_handle(buffer->vcsm_handle);
+		if (!buffer->vc_handle) {
+			pr_err("%s: vc_sm_int_handle failed %d\n",
+			       __func__, ret);
+			vc_sm_free(buffer->vcsm_handle);
+			return ret;
+		}
+	}
+#endif
+
 	ret = buffer_from_host(instance, port, buffer);
 	if (ret == -EINVAL) {
 		/* Port is disabled. Queue for when it is enabled. */
@@ -1683,6 +1740,7 @@ int mmal_vchi_buffer_init(struct vchiq_mmal_instance *instance,
 		return (PTR_ERR(msg_context));
 
 	buf->msg_context = msg_context;
+
 	return 0;
 }
 
@@ -1695,6 +1753,15 @@ int mmal_vchi_buffer_cleanup(struct mmal_buffer *buf)
 		release_msg_context(msg_context);
 	buf->msg_context = NULL;
 
+#if defined(CONFIG_BCM_VC_SM)
+	if (buf->vcsm_handle) {
+		int ret;
+
+		ret = vc_sm_free(buf->vcsm_handle);
+		if (ret)
+			pr_err("%s: vcsm_free failed, ret %d\n", __func__, ret);
+	}
+#endif
 	return 0;
 }
 
diff --git a/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.h b/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.h
index d5545f4aee63..ed9d7578be50 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.h
+++ b/drivers/staging/vc04_services/bcm2835-camera/mmal-vchiq.h
@@ -78,6 +78,8 @@ struct vchiq_mmal_port {
 	vchiq_mmal_buffer_cb buffer_cb;
 	/* callback context */
 	void *cb_ctx;
+
+	bool zero_copy;
 };
 
 struct vchiq_mmal_component {
-- 
2.17.0

