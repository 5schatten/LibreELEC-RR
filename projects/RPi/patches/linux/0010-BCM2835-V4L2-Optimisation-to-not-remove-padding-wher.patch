From b07bdea1914aaf4b76d5b6c5a4c37f8139860565 Mon Sep 17 00:00:00 2001
From: Dave Stevenson <6by9@users.noreply.github.com>
Date: Tue, 6 Sep 2016 16:44:43 +0100
Subject: [PATCH 10/80] BCM2835-V4L2: Optimisation to not remove padding where
 possible

Interleaved RGB and single plane YUV formats can be delivered
by the GPU without the secondary step of removing padding,
as the bytesperline field can be completed appropriately.

Planar YUV has to remain with the GPU removing padding when
necessary, as there is no way to report that there is
padding between the planes (ie on the height).
The multi-planar formats are NOT applicable, as there is no
easy way to make them contiguous in memory (ie one large
allocation that gets broken up). The whole task is passed
across to videobuf2 which has no notion of that requirement.
---
 .../bcm2835-camera/bcm2835-camera.c           | 47 ++++++++++++++-----
 .../bcm2835-camera/mmal-common.h              |  3 ++
 2 files changed, 38 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c b/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
index f01eea3af694..9e6d62184452 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
+++ b/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
@@ -66,6 +66,11 @@ MODULE_PARM_DESC(max_video_width, "Threshold for video mode");
 module_param(max_video_height, int, 0644);
 MODULE_PARM_DESC(max_video_height, "Threshold for video mode");
 
+static int always_remove_padding = 0;
+module_param(always_remove_padding, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(always_remove_padding,
+	"Always remove all padding from the image (for apps that ignore bytesperline)");
+
 /* global device data array */
 static struct bm2835_mmal_dev *gdev[MAX_BCM2835_CAMERAS];
 
@@ -88,6 +93,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 12,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 1,
+	 .remove_padding = 1,
 	 },
 	{
 	 .name = "4:2:2, packed, YUYV",
@@ -97,6 +103,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 16,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 2,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "RGB24 (LE)",
@@ -106,6 +113,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 24,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 3,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "JPEG",
@@ -115,6 +123,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 8,
 	 .mmal_component = MMAL_COMPONENT_IMAGE_ENCODE,
 	 .ybbp = 0,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "H264",
@@ -124,6 +133,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 8,
 	 .mmal_component = MMAL_COMPONENT_VIDEO_ENCODE,
 	 .ybbp = 0,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "MJPEG",
@@ -133,6 +143,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 8,
 	 .mmal_component = MMAL_COMPONENT_VIDEO_ENCODE,
 	 .ybbp = 0,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "4:2:2, packed, YVYU",
@@ -142,6 +153,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 16,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 2,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "4:2:2, packed, VYUY",
@@ -151,6 +163,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 16,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 2,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "4:2:2, packed, UYVY",
@@ -160,6 +173,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 16,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 2,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "4:2:0, planar, NV12",
@@ -169,6 +183,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 12,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 1,
+	 .remove_padding = 1,
 	 },
 	{
 	 .name = "RGB24 (BE)",
@@ -178,6 +193,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 24,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 3,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "4:2:0, planar, YVU",
@@ -187,6 +203,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 12,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 1,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "4:2:0, planar, NV21",
@@ -196,6 +213,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 12,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 1,
+	 .remove_padding = 0,
 	 },
 	{
 	 .name = "RGB32 (BE)",
@@ -205,6 +223,7 @@ static struct mmal_fmt formats[] = {
 	 .depth = 32,
 	 .mmal_component = MMAL_COMPONENT_CAMERA,
 	 .ybbp = 4,
+	 .remove_padding = 0,
 	 },
 };
 
@@ -961,9 +980,17 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 			      &f->fmt.pix.height, MIN_HEIGHT, dev->max_height,
 			      1, 0);
 	f->fmt.pix.bytesperline = f->fmt.pix.width * mfmt->ybbp;
+	if (!mfmt->remove_padding && !always_remove_padding) {
+		int align_mask = ((32 * mfmt->depth) >> 3) - 1;
+		/* GPU isn't removing padding, so stride is aligned to 32 */
+		f->fmt.pix.bytesperline =
+			(f->fmt.pix.bytesperline + align_mask)&~align_mask;
+		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
+			"Not removing padding, so bytes/line = %d, (align_mask %d)\n", f->fmt.pix.bytesperline, align_mask);
+	}
 
 	/* Image buffer has to be padded to allow for alignment, even though
-	 * we then remove that padding before delivering the buffer.
+	 * we sometimes then remove that padding before delivering the buffer.
 	 */
 	f->fmt.pix.sizeimage = ((f->fmt.pix.height + 15) & ~15) *
 			(((f->fmt.pix.width + 31) & ~31) * mfmt->depth) >> 3;
@@ -996,6 +1023,7 @@ static int mmal_setup_components(struct bm2835_mmal_dev *dev,
 	struct vchiq_mmal_port *port = NULL, *camera_port = NULL;
 	struct vchiq_mmal_component *encode_component = NULL;
 	struct mmal_fmt *mfmt = get_format(f);
+	u32 remove_padding;
 
 	BUG_ON(!mfmt);
 
@@ -1064,6 +1092,12 @@ static int mmal_setup_components(struct bm2835_mmal_dev *dev,
 			camera_port->format.encoding = MMAL_ENCODING_RGB24;
 	}
 
+	remove_padding = mfmt->remove_padding || always_remove_padding;
+	vchiq_mmal_port_parameter_set(dev->instance,
+		camera_port,
+		MMAL_PARAMETER_NO_IMAGE_PADDING,
+		&remove_padding, sizeof(remove_padding));
+
 	camera_port->format.encoding_variant = 0;
 	camera_port->es.video.width = f->fmt.pix.width;
 	camera_port->es.video.height = f->fmt.pix.height;
@@ -1541,7 +1575,6 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 {
 	int ret;
 	struct mmal_es_format_local *format;
-	u32 bool_true = 1;
 	u32 supported_encodings[MAX_SUPPORTED_ENCODINGS];
 	int param_size;
 	struct vchiq_mmal_component  *camera;
@@ -1625,11 +1658,6 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 	format->es->video.frame_rate.num = 0; /* Rely on fps_range */
 	format->es->video.frame_rate.den = 1;
 
-	vchiq_mmal_port_parameter_set(dev->instance,
-				      &camera->output[MMAL_CAMERA_PORT_VIDEO],
-				      MMAL_PARAMETER_NO_IMAGE_PADDING,
-				      &bool_true, sizeof(bool_true));
-
 	format = &camera->output[MMAL_CAMERA_PORT_CAPTURE].format;
 
 	format->encoding = MMAL_ENCODING_OPAQUE;
@@ -1651,11 +1679,6 @@ static int __init mmal_init(struct bm2835_mmal_dev *dev)
 	dev->capture.enc_profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH;
 	dev->capture.enc_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;
 
-	vchiq_mmal_port_parameter_set(dev->instance,
-				      &camera->output[MMAL_CAMERA_PORT_CAPTURE],
-				      MMAL_PARAMETER_NO_IMAGE_PADDING,
-				      &bool_true, sizeof(bool_true));
-
 	/* get the preview component ready */
 	ret = vchiq_mmal_component_init(
 			dev->instance, "ril.video_render",
diff --git a/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h b/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h
index 840fd139e033..7790675e167d 100644
--- a/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h
+++ b/drivers/staging/vc04_services/bcm2835-camera/mmal-common.h
@@ -31,6 +31,9 @@ struct mmal_fmt {
 	int   depth;
 	u32   mmal_component;  /* MMAL component index to be used to encode */
 	u32   ybbp;            /* depth of first Y plane for planar formats */
+	bool  remove_padding;  /* Does the GPU have to remove padding,
+				* or can we do hide padding via bytesperline.
+				*/
 };
 
 /* buffer for one video frame */
-- 
2.17.0

