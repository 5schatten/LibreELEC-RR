From 15a0e6ea176956a197ea5885d41a773287451080 Mon Sep 17 00:00:00 2001
From: Dave Stevenson <dave.stevenson@raspberrypi.org>
Date: Thu, 29 Mar 2018 10:01:41 +0100
Subject: [PATCH 56/80] staging: vc04_services: bcm2835-codec: Declare this
 working?!

Signed-off-by: Dave Stevenson <dave.stevenson@raspberrypi.org>
---
 .../bcm2835-codec/bcm2835-v4l2-codec.c        | 230 ++++++++++--------
 1 file changed, 133 insertions(+), 97 deletions(-)

diff --git a/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c b/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
index b659ecc7c8fb..5730bd300b01 100644
--- a/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
+++ b/drivers/staging/vc04_services/bcm2835-codec/bcm2835-v4l2-codec.c
@@ -56,6 +56,8 @@ MODULE_PARM_DESC(debug, "activates debug info");
 #define MAX_W 1920
 #define MAX_H 1088
 #define BPL_ALIGN 32
+#define DEFAULT_WIDTH			640
+#define DEFAULT_HEIGHT			480
 #define DEFAULT_COMPRESSED_BUF_SIZE	(512 << 10)
 
 /* Flags that indicate a format can be used for capture/output */
@@ -197,13 +199,13 @@ struct bcm2835_codec_q_data {
 	 * being determined from them.
 	 */
 	/* Buffer width/height */
-	unsigned int		width;
+	unsigned int		bytesperline;
 	unsigned int		height;
 	/* Crop size used for selection handling */
 	unsigned int		crop_width;
 	unsigned int		crop_height;
+	bool			selection_set;
 
-	unsigned int		bytesperline;
 	unsigned int		sizeimage;
 	unsigned int		sequence;
 	struct bcm2835_codec_fmt	*fmt;
@@ -226,6 +228,7 @@ static struct bcm2835_codec_fmt *get_default_format(bool decode, bool capture)
 	return &get_format_list(decode, capture)->list[0];
 
 }
+
 static struct bcm2835_codec_fmt *find_format(struct v4l2_format *f, bool decode,
 					     bool capture)
 {
@@ -282,6 +285,7 @@ struct bcm2835_codec_ctx {
 
 	/* Source and destination queue data */
 	struct bcm2835_codec_q_data   q_data[2];
+	s32  bitrate;
 
 	bool aborting;
 	int num_ip_buffers;
@@ -349,14 +353,22 @@ static void job_abort(void *priv)
 	ctx->aborting = 1;
 }
 
-static void setup_mmal_port_format(struct bcm2835_codec_q_data *q_data,
+static inline unsigned int get_sizeimage(int bpl, int height,
+					 struct bcm2835_codec_fmt *fmt)
+{
+	return (bpl * height * fmt->size_multiplier_x2) >> 1;
+}
+
+static void setup_mmal_port_format(struct bcm2835_codec_ctx *ctx,
+				   bool decode,
+				   struct bcm2835_codec_q_data *q_data,
 				   struct vchiq_mmal_port *port)
 {
 	port->format.encoding = q_data->fmt->mmal_fmt;
 	if (!(q_data->fmt->flags & V4L2_FMT_FLAG_COMPRESSED)) {
 		/* Raw image format - set width/height */
-		port->es.video.width = ALIGN(q_data->width, 32);
-		port->es.video.height = ALIGN(q_data->height, 16);
+		port->es.video.width = q_data->bytesperline;
+		port->es.video.height = q_data->height;
 		port->es.video.crop.x = 0;
 		port->es.video.crop.y = 0;
 		port->es.video.crop.width = q_data->crop_width;
@@ -365,16 +377,17 @@ static void setup_mmal_port_format(struct bcm2835_codec_q_data *q_data,
 		port->es.video.frame_rate.den = 1;
 	} else {
 		/* Compressed format - leave resolution as 0 for decode */
-		if (0 /*dev->decode*/) {
+		if (decode) {
 			port->es.video.width = 0;
 			port->es.video.height = 0;
 			port->es.video.crop.width = 0;
 			port->es.video.crop.height = 0;
 		} else {
-			port->es.video.width = ALIGN(q_data->width, 32);
-			port->es.video.height = ALIGN(q_data->height, 16);
+			port->es.video.width = q_data->bytesperline;
+			port->es.video.height = q_data->height;
 			port->es.video.crop.width = q_data->crop_width;
 			port->es.video.crop.height = q_data->crop_height;
+			port->format.bitrate = ctx->bitrate;
 		}
 		port->es.video.crop.x = 0;
 		port->es.video.crop.y = 0;
@@ -483,17 +496,20 @@ static void op_buffer_cb(struct vchiq_mmal_instance *instance,
 			}
 			v4l2_dbg(1, debug, &ctx->dev->v4l2_dev, "%s: Format changed is video %u\n",
 				__func__, format->format.type);
-			v4l2_err(&ctx->dev->v4l2_dev, "%s: Format changed to %ux%u, crop %ux%u\n",
+			v4l2_err(&ctx->dev->v4l2_dev, "%s: Format changed to %ux%u, crop %ux%u, colourspace %08X\n",
 				 __func__, format->es.video.width,
 				 format->es.video.height,
 				 format->es.video.crop.width,
-				 format->es.video.crop.height);
+				 format->es.video.crop.height,
+				 format->es.video.color_space);
 
 			q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
-			q_data->width = format->es.video.crop.width;
-			q_data->height = format->es.video.crop.height;
-			q_data->bytesperline = ALIGN(format->es.video.width, 32);
+			q_data->crop_width = format->es.video.crop.width;
+			q_data->crop_height = format->es.video.crop.height;
+			q_data->bytesperline = format->es.video.crop.width;
+			q_data->height = format->es.video.height;
 			q_data->sizeimage = format->buffer_size_min;
+			ctx->colorspace = format->es.video.color_space;
 
 			queue_res_chg_event(ctx);
 			break;
@@ -674,7 +690,7 @@ static int vidioc_g_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f)
 
 	q_data = get_q_data(ctx, f->type);
 
-	f->fmt.pix.width	= q_data->width;
+	f->fmt.pix.width	= q_data->crop_width;
 	f->fmt.pix.height	= q_data->height;
 	f->fmt.pix.field	= V4L2_FIELD_NONE;
 	f->fmt.pix.pixelformat	= q_data->fmt->fourcc;
@@ -718,12 +734,19 @@ static int vidioc_try_fmt(struct v4l2_format *f, struct bcm2835_codec_fmt *fmt)
 		if (f->fmt.pix.height < MIN_H)
 			f->fmt.pix.height = MIN_H;
 
+		/*
+		 * Buffer must have a vertical alignment of 16 lines.
+		 * The selection will reflect any cropping rectangle when only
+		 * some of the pixels are active.
+		 */
+		f->fmt.pix.height = ALIGN(f->fmt.pix.height, 16);
+
 		f->fmt.pix.bytesperline =
 				ALIGN((f->fmt.pix.width * fmt->depth) >> 3,
 				      fmt->bytesperline_align);
-		f->fmt.pix.sizeimage = (ALIGN(f->fmt.pix.height, 16) *
-					f->fmt.pix.bytesperline *
-					fmt->size_multiplier_x2) >> 1;
+		f->fmt.pix.sizeimage = get_sizeimage(f->fmt.pix.bytesperline,
+						     f->fmt.pix.height,
+						     fmt);
 	} else {
 		f->fmt.pix.bytesperline = 0;
 		f->fmt.pix.sizeimage = DEFAULT_COMPRESSED_BUF_SIZE;
@@ -772,12 +795,13 @@ static int vidioc_try_fmt_vid_out(struct file *file, void *priv,
 	}
 
 	if (!f->fmt.pix.colorspace)
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;
+		f->fmt.pix.colorspace = ctx->colorspace;
 
 	return vidioc_try_fmt(f, fmt);
 }
 
-static int vidioc_s_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f)
+static int vidioc_s_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f,
+			unsigned int requested_height)
 {
 	struct bcm2835_codec_q_data *q_data;
 	struct vb2_queue *vq;
@@ -805,36 +829,32 @@ static int vidioc_s_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f)
 		return -EBUSY;
 	}
 
-	q_data->fmt	= find_format(f, ctx->dev->decode,
-				      f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE);
-	q_data->width	= f->fmt.pix.width;
-	q_data->height	= f->fmt.pix.height;
+	q_data->fmt = find_format(f, ctx->dev->decode,
+				  f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	q_data->crop_width = f->fmt.pix.width;
+	q_data->height = f->fmt.pix.height;
+	if (!q_data->selection_set)
+		q_data->crop_height = requested_height;
 
-	if (!q_data->fmt->flags & V4L2_FMT_FLAG_COMPRESSED) {
-		q_data->bytesperline =
-				ALIGN((f->fmt.pix.width * q_data->fmt->depth) >> 3,
-				      q_data->fmt->bytesperline_align);
-		q_data->sizeimage = f->fmt.pix.sizeimage;
-	} else {
-		q_data->bytesperline = 0;
-		q_data->sizeimage = DEFAULT_COMPRESSED_BUF_SIZE;
-	}
-	f->fmt.pix.bytesperline = q_data->bytesperline;
+	/* All parameters should have been set correctly by try_fmt */
+	q_data->bytesperline = f->fmt.pix.bytesperline;
+	q_data->sizeimage = f->fmt.pix.sizeimage;
 
-	setup_mmal_port_format(q_data, port);
+	setup_mmal_port_format(ctx, ctx->dev->decode, q_data, port);
 	ret = vchiq_mmal_port_set_format(ctx->dev->instance, port);
 	if (ret)
 		v4l2_err(&ctx->dev->v4l2_dev, "%s: Failed vchiq_mmal_port_set_format on port, ret %d\n",
 			 __func__, ret);
 
-	if (q_data->sizeimage < port->minimum_buffer.size)
-		v4l2_err(&ctx->dev->v4l2_dev, "%s: Current buffer size of %u < min buf size %u\n",
+	if (q_data->sizeimage < port->minimum_buffer.size) {
+		v4l2_err(&ctx->dev->v4l2_dev, "%s: Current buffer size of %u < min buf size %u - driver mismatch to MMAL\n",
 			 __func__, q_data->sizeimage, port->minimum_buffer.size);
+	}
 
 
 	v4l2_dbg(1, debug, &ctx->dev->v4l2_dev,	"Set format for type %d, wxh: %dx%d, fmt: %08x, size %u\n",
-		f->type, q_data->width, q_data->height, q_data->fmt->fourcc,
-		q_data->sizeimage);
+		f->type, q_data->crop_width, q_data->height,
+		q_data->fmt->fourcc, q_data->sizeimage);
 
 	if (ctx->dev->decode && q_data->fmt->flags & V4L2_FMT_FLAG_COMPRESSED &&
 	    f->fmt.pix.width && f->fmt.pix.height) {
@@ -842,7 +862,7 @@ static int vidioc_s_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f)
 		 * On the decoder, if provided with a resolution on the input
 		 * side, then replicate that to the output side.
 		 * GStreamer appears not to support V4L2_EVENT_SOURCE_CHANGE,
-		 * nor sets up a resolution on the output side, therefore
+		 * nor set up a resolution on the output side, therefore
 		 * we can't decode anything at a resolution other than the
 		 * default one.
 		 */
@@ -851,19 +871,21 @@ static int vidioc_s_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f)
 		struct vchiq_mmal_port *port_dst = &ctx->component->output[0];
 
 		v4l2_dbg(1, debug, &ctx->dev->v4l2_dev,	"Copying input res of %ux%u to output\n",
-			q_data->width, q_data->height);
+			q_data->crop_width, q_data->crop_height);
 
-		q_data_dst->width = q_data->width;
-		q_data_dst->height = q_data->height;
+		q_data_dst->crop_width = q_data->crop_width;
+		q_data_dst->crop_height = q_data->crop_height;
+		q_data_dst->height = ALIGN(q_data->crop_height, 16);
 
 		q_data_dst->bytesperline =
 			ALIGN((f->fmt.pix.width * q_data_dst->fmt->depth) >> 3,
 			      q_data_dst->fmt->bytesperline_align);
-		q_data_dst->sizeimage = (ALIGN(q_data_dst->width, 16) *
-					q_data_dst->bytesperline *
-					q_data->fmt->size_multiplier_x2) >> 1;
+		q_data_dst->sizeimage = get_sizeimage(q_data_dst->bytesperline,
+						      q_data_dst->height,
+						      q_data_dst->fmt);
 
-		setup_mmal_port_format(q_data_dst, port_dst);
+		setup_mmal_port_format(ctx, ctx->dev->decode, q_data_dst,
+				       port_dst);
 		ret = vchiq_mmal_port_set_format(ctx->dev->instance, port_dst);
 		if (ret)
 			v4l2_err(&ctx->dev->v4l2_dev, "%s: Failed vchiq_mmal_port_set_format on output port, ret %d\n",
@@ -875,32 +897,27 @@ static int vidioc_s_fmt(struct bcm2835_codec_ctx *ctx, struct v4l2_format *f)
 static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 				struct v4l2_format *f)
 {
+	unsigned int height = f->fmt.pix.height;
 	int ret;
 
 	ret = vidioc_try_fmt_vid_cap(file, priv, f);
 	if (ret)
 		return ret;
 
-	return vidioc_s_fmt(file2ctx(file), f);
+	return vidioc_s_fmt(file2ctx(file), f, height);
 }
 
 static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 				struct v4l2_format *f)
 {
-	struct bcm2835_codec_ctx *ctx = file2ctx(file);
+	unsigned int height = f->fmt.pix.height;
 	int ret;
 
 	ret = vidioc_try_fmt_vid_out(file, priv, f);
 	if (ret)
 		return ret;
 
-	ret = vidioc_s_fmt(file2ctx(file), f);
-	if (!ret) {
-		ctx->colorspace = f->fmt.pix.colorspace;
-		ctx->xfer_func = f->fmt.pix.xfer_func;
-		ctx->ycbcr_enc = f->fmt.pix.ycbcr_enc;
-		ctx->quant = f->fmt.pix.quantization;
-	}
+	ret = vidioc_s_fmt(file2ctx(file), f, height);
 	return ret;
 }
 
@@ -928,8 +945,8 @@ static int vidioc_g_selection(struct file *file, void *priv,
 		case V4L2_SEL_TGT_COMPOSE_BOUNDS:
 			s->r.left = 0;
 			s->r.top = 0;
-			s->r.width = q_data->width;
-			s->r.height = q_data->height;
+			s->r.width = q_data->crop_width;
+			s->r.height = q_data->crop_height;
 			break;
 		default:
 			return -EINVAL;
@@ -940,7 +957,7 @@ static int vidioc_g_selection(struct file *file, void *priv,
 		case V4L2_SEL_TGT_CROP_BOUNDS:
 			s->r.top = 0;
 			s->r.left = 0;
-			s->r.width = q_data->width;
+			s->r.width = q_data->bytesperline;
 			s->r.height = q_data->height;
 			break;
 		case V4L2_SEL_TGT_CROP:
@@ -961,24 +978,28 @@ static int vidioc_s_selection(struct file *file, void *priv,
 			      struct v4l2_selection *s)
 {
 	struct bcm2835_codec_ctx *ctx = file2ctx(file);
-	struct bcm2835_codec_q_data *q_data;
+	struct bcm2835_codec_q_data *q_data = NULL;
 
+	v4l2_dbg(2, debug, &ctx->dev->v4l2_dev, "%s: ctx %p, type %d, q_data %p, target %d, rect x/y %d/%d, w/h %ux%u\n",
+		 __func__, ctx, s->type, q_data, s->target, s->r.left, s->r.top,
+		 s->r.width, s->r.height);
 
-printk("%s: ctx %p, type %d, q_data %p, target %d\n", __func__, ctx, s->type, q_data, s->target);
 	if ((s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ^ !ctx->dev->decode)
 		/* CAPTURE on encode, or OUTPUT on decode - not valid. */
 		return -EINVAL;
 
 	q_data = get_q_data(ctx, s->type);
-printk("%s: ctx %p, type %d, q_data %p, target %d\n", __func__, ctx, s->type, q_data, s->target);
 	if (ctx->dev->decode) {
 		switch (s->target) {
 		case V4L2_SEL_TGT_COMPOSE:
-			/* Copy mtk-vcodec and do not allow settings crop */
+			/* Accept cropped image */
 			s->r.left = 0;
 			s->r.top = 0;
-			s->r.width = q_data->crop_width;
-			s->r.height = q_data->crop_height;
+			s->r.width = min(s->r.width, q_data->crop_width);
+			s->r.height = min(s->r.height, q_data->height);
+			q_data->crop_width = s->r.width;
+			q_data->crop_height = s->r.height;
+			q_data->selection_set = true;
 			break;
 		default:
 			return -EINVAL;
@@ -989,10 +1010,11 @@ printk("%s: ctx %p, type %d, q_data %p, target %d\n", __func__, ctx, s->type, q_
 			/* Only support crop from (0,0) */
 			s->r.top = 0;
 			s->r.left = 0;
-			s->r.width = min(s->r.width, q_data->width);
-			s->r.height = min(s->r.height, q_data->height);
+			s->r.width = min(s->r.width, q_data->crop_width);
+			s->r.height = min(s->r.height, q_data->crop_height);
 			q_data->crop_width = s->r.width;
 			q_data->crop_height = s->r.height;
+			q_data->selection_set = true;
 			break;
 		default:
 			return -EINVAL;
@@ -1030,6 +1052,7 @@ static int bcm2835_codec_s_ctrl(struct v4l2_ctrl *ctrl)
 						    MMAL_PARAMETER_VIDEO_BIT_RATE,
 						    &ctrl->val,
 						    sizeof(ctrl->val));
+		ctx->bitrate = ctrl->val;
 		break;
 
 	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE: {
@@ -1195,8 +1218,9 @@ static int bcm2835_codec_buf_prepare(struct vb2_buffer *vb)
 	}
 
 	if (vb2_plane_size(vb, 0) < q_data->sizeimage) {
-		dprintk(ctx->dev, "%s data will not fit into plane (%lu < %lu)\n",
-				__func__, vb2_plane_size(vb, 0), (long)q_data->sizeimage);
+		v4l2_err(&ctx->dev->v4l2_dev, "%s data will not fit into plane (%lu < %lu)\n",
+			 __func__, vb2_plane_size(vb, 0),
+			 (long)q_data->sizeimage);
 		return -EINVAL;
 	}
 
@@ -1477,28 +1501,47 @@ static int bcm2835_codec_open(struct file *file)
 	ctx->q_data[V4L2_M2M_SRC].fmt = get_default_format(dev->decode, false);
 	ctx->q_data[V4L2_M2M_DST].fmt = get_default_format(dev->decode, true);
 	if (dev->decode) {
-		ctx->q_data[V4L2_M2M_SRC].width = 0;
+		ctx->q_data[V4L2_M2M_SRC].crop_width = 0;
+		ctx->q_data[V4L2_M2M_SRC].crop_height = 0;
 		ctx->q_data[V4L2_M2M_SRC].height = 0;
-		ctx->q_data[V4L2_M2M_DST].width = 640;
-		ctx->q_data[V4L2_M2M_DST].height = 480;
+		ctx->q_data[V4L2_M2M_SRC].bytesperline = 0;
+		ctx->q_data[V4L2_M2M_SRC].sizeimage =
+						DEFAULT_COMPRESSED_BUF_SIZE;
+
+		ctx->q_data[V4L2_M2M_DST].crop_width = DEFAULT_WIDTH;
+		ctx->q_data[V4L2_M2M_DST].crop_height = DEFAULT_HEIGHT;
+		ctx->q_data[V4L2_M2M_DST].bytesperline = DEFAULT_WIDTH;
+		ctx->q_data[V4L2_M2M_DST].height = DEFAULT_HEIGHT;
+		get_sizeimage(ctx->q_data[V4L2_M2M_DST].bytesperline,
+			      ctx->q_data[V4L2_M2M_DST].height,
+			      ctx->q_data[V4L2_M2M_DST].fmt);
 	} else {
-		ctx->q_data[V4L2_M2M_SRC].width = 640;
-		ctx->q_data[V4L2_M2M_SRC].height = 480;
-		ctx->q_data[V4L2_M2M_DST].width = 640;
-		ctx->q_data[V4L2_M2M_DST].height = 480;
+		ctx->q_data[V4L2_M2M_SRC].crop_width = DEFAULT_WIDTH;
+		ctx->q_data[V4L2_M2M_SRC].crop_height = DEFAULT_HEIGHT;
+		ctx->q_data[V4L2_M2M_SRC].bytesperline = DEFAULT_WIDTH;
+		ctx->q_data[V4L2_M2M_SRC].height = DEFAULT_HEIGHT;
+		ctx->q_data[V4L2_M2M_SRC].sizeimage =
+			get_sizeimage(ctx->q_data[V4L2_M2M_SRC].bytesperline,
+				      ctx->q_data[V4L2_M2M_SRC].height,
+				      ctx->q_data[V4L2_M2M_SRC].fmt);
+
+		ctx->q_data[V4L2_M2M_DST].crop_width = DEFAULT_WIDTH;
+		ctx->q_data[V4L2_M2M_DST].crop_height = DEFAULT_HEIGHT;
+		ctx->q_data[V4L2_M2M_DST].bytesperline = DEFAULT_WIDTH;
+		ctx->q_data[V4L2_M2M_DST].height = DEFAULT_HEIGHT;
+		ctx->q_data[V4L2_M2M_DST].sizeimage =
+						DEFAULT_COMPRESSED_BUF_SIZE;
 	}
 
 	ctx->colorspace = V4L2_COLORSPACE_REC709;
+	ctx->bitrate = 10 * 1000 * 1000;
 
-	setup_mmal_port_format(&ctx->q_data[V4L2_M2M_SRC],
+	setup_mmal_port_format(ctx, dev->decode, &ctx->q_data[V4L2_M2M_SRC],
 			       &ctx->component->input[0]);
 
-	setup_mmal_port_format(&ctx->q_data[V4L2_M2M_DST],
+	setup_mmal_port_format(ctx, dev->decode, &ctx->q_data[V4L2_M2M_DST],
 			       &ctx->component->output[0]);
 
-	if (!dev->decode)
-		/* CHECK: is this still required as we have a ctrl for bitrate? */
-		ctx->component->output[0].format.bitrate = 10 * 1000 * 1000;
 
 	rc = vchiq_mmal_port_set_format(dev->instance,
 					 &ctx->component->input[0]);
@@ -1511,24 +1554,17 @@ static int bcm2835_codec_open(struct file *file)
 		goto destroy_component;
 
 	if (dev->decode) {
-		ctx->q_data[V4L2_M2M_SRC].sizeimage = DEFAULT_COMPRESSED_BUF_SIZE;
-		ctx->q_data[V4L2_M2M_SRC].bytesperline = 0;
-
-		ctx->q_data[V4L2_M2M_DST].sizeimage =
-			ctx->component->output[0].minimum_buffer.size;
-		ctx->q_data[V4L2_M2M_DST].bytesperline =
-				ALIGN((ctx->q_data[V4L2_M2M_DST].width * ctx->q_data[V4L2_M2M_DST].fmt->depth) >> 3,
-				      ctx->q_data[V4L2_M2M_DST].fmt->bytesperline_align);
+		if (ctx->q_data[V4L2_M2M_DST].sizeimage <
+			ctx->component->output[0].minimum_buffer.size)
+			v4l2_err(&dev->v4l2_dev, "buffer size mismatch sizeimage %u < min size %u\n",
+				 ctx->q_data[V4L2_M2M_DST].sizeimage,
+				 ctx->component->output[0].minimum_buffer.size);
 	} else {
-		ctx->q_data[V4L2_M2M_SRC].bytesperline =
-				ALIGN((ctx->q_data[V4L2_M2M_SRC].width * ctx->q_data[V4L2_M2M_SRC].fmt->depth) >> 3,
-				      ctx->q_data[V4L2_M2M_SRC].fmt->bytesperline_align);
-		ctx->q_data[V4L2_M2M_SRC].sizeimage =
-			ctx->component->output[0].minimum_buffer.size;
-
-		ctx->q_data[V4L2_M2M_DST].sizeimage =
-					DEFAULT_COMPRESSED_BUF_SIZE;
-		ctx->q_data[V4L2_M2M_DST].bytesperline = 0;
+		if (ctx->q_data[V4L2_M2M_SRC].sizeimage <
+			ctx->component->output[0].minimum_buffer.size)
+			v4l2_err(&dev->v4l2_dev, "buffer size mismatch sizeimage %u < min size %u\n",
+				 ctx->q_data[V4L2_M2M_SRC].sizeimage,
+				 ctx->component->output[0].minimum_buffer.size);
 	}
 
 
-- 
2.17.0

